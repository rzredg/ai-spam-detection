let vocabulary = [];
let model;

// Function to build vocabulary from dataset
async function buildVocabulary(data) {
    const wordSet = new Set();  // Use a set to store unique words

    data.forEach(item => {
        const words = item.text.toLowerCase().split(/\W+/);  // Split by non-word characters
        words.forEach(word => {
            if (word) {
                wordSet.add(word);  // Add each word to the set
            }
        });
    });

    vocabulary = Array.from(wordSet);  // Convert set to array
    console.log('Vocabulary size:', vocabulary.length);  // For debugging
}

// Function to convert a comment into a vector
const vectorizeText = (text) => {
    const words = text.toLowerCase().split(/\W+/);  // Split by non-word characters
    const vector = new Array(vocabulary.length).fill(0);  // Initialize an array of 0s

    words.forEach(word => {
        const index = vocabulary.indexOf(word);  // Find the index of the word in the vocabulary
        if (index !== -1) {
            vector[index] = 1;  // If the word is found, set the corresponding position to 1
        }
    });

    return vector;
};

// Load and vectorize dataset
async function loadDataset() {
    const response = await fetch('dataset.json');
    const data = await response.json();

    await buildVocabulary(data);  // Build the vocabulary from the dataset

    // Convert dataset into vectors and labels
    const inputs = data.map(item => vectorizeText(item.text));
    const labels = data.map(item => item.label);

    // Convert to tensors
    const inputTensor = tf.tensor2d(inputs);
    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);

    // Split into training and testing sets
    const splitIndex = Math.floor(inputs.length * 0.8);
    const trainInputs = inputTensor.slice([0, 0], [splitIndex, -1]);
    const trainLabels = labelTensor.slice([0, 0], [splitIndex, -1]);
    const testInputs = inputTensor.slice([splitIndex, 0], [-1, -1]);
    const testLabels = labelTensor.slice([splitIndex, 0], [-1, -1]);

    return { trainInputs, trainLabels, testInputs, testLabels };
}

// Train the model
async function trainModel() {
    // Load and preprocess the dataset
    const { trainInputs, trainLabels, testInputs, testLabels } = await loadDataset();

    // Define the model after the vocabulary is built
    model = tf.sequential();
    model.add(tf.layers.dense({ units: 32, activation: 'relu', inputShape: [vocabulary.length] }));
    model.add(tf.layers.dense({ units: 16, activation: 'relu' }));
    model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));  // Sigmoid for binary classification

    // Compile the model
    model.compile({
        optimizer: 'adam',
        loss: 'binaryCrossentropy',
        metrics: ['accuracy']
    });

    // Train the model on the training set
    await model.fit(trainInputs, trainLabels, {
        epochs: 30,  // You can experiment with more epochs
        batchSize: 32,  // You can increase batch size as well since you have more data
        validationData: [testInputs, testLabels],
        callbacks: {
            onEpochEnd: function(epoch, logs) {  // Correct function format for the callback
                console.log(`Epoch ${epoch + 1} completed`);
                console.log(`Loss: ${logs.loss}, Accuracy: ${logs.accuracy}`);
                console.log(`Validation Loss: ${logs.val_loss}, Validation Accuracy: ${logs.val_accuracy}`);
            }
        }
    });

    // Evaluate the model on the test set
    const [loss, accuracy] = model.evaluate(testInputs, testLabels);
    const lossValue = loss.dataSync();
    const accuracyValue = accuracy.dataSync();
    
    console.log(`Test Loss: ${lossValue}`);
    console.log(`Test Accuracy: ${accuracyValue}`);
}

// Function to predict if a comment is spam
async function predict(text) {
    const vector = vectorizeText(text);
    const inputTensor = tf.tensor2d([vector]);
    const prediction = model.predict(inputTensor);
    const result = await prediction.data();
    console.log('Raw prediction:', result);  // Log raw output for inspection
    return result[0] > 0.5 ? 'Spam' : 'Not Spam';
}

async function getComment() {
    // Ensure the model is trained before making predictions
    if (!model) {
        console.error("Model is not trained yet.");
        return;
    }

    // get input value 
    let comment = document.getElementById("input").value;
    // get output value - prediction generated by the AI
    const result = await predict(comment);
    // set output value - display the result
    document.getElementById("output").value = result;
}

// Train the model and then make predictions
trainModel().then(() => {
    document.getElementById("submit").disabled = false; // Allow user to click the "submit" button after training
});